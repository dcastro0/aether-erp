// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: orders.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createOrder = `-- name: CreateOrder :one
INSERT INTO orders (
  organization_id, customer_id, total_amount, status
) VALUES (
  $1, $2, $3, $4
) RETURNING id, organization_id, customer_id, total_amount, status, created_at, payment_method
`

type CreateOrderParams struct {
	OrganizationID pgtype.UUID    `json:"organization_id"`
	CustomerID     pgtype.UUID    `json:"customer_id"`
	TotalAmount    pgtype.Numeric `json:"total_amount"`
	Status         string         `json:"status"`
}

func (q *Queries) CreateOrder(ctx context.Context, arg CreateOrderParams) (Order, error) {
	row := q.db.QueryRow(ctx, createOrder,
		arg.OrganizationID,
		arg.CustomerID,
		arg.TotalAmount,
		arg.Status,
	)
	var i Order
	err := row.Scan(
		&i.ID,
		&i.OrganizationID,
		&i.CustomerID,
		&i.TotalAmount,
		&i.Status,
		&i.CreatedAt,
		&i.PaymentMethod,
	)
	return i, err
}

const createOrderItem = `-- name: CreateOrderItem :one
INSERT INTO order_items (
  order_id, product_id, quantity, unit_price, total_price
) VALUES (
  $1, $2, $3, $4, $5
) RETURNING id, order_id, product_id, quantity, unit_price, total_price
`

type CreateOrderItemParams struct {
	OrderID    pgtype.UUID    `json:"order_id"`
	ProductID  pgtype.UUID    `json:"product_id"`
	Quantity   int32          `json:"quantity"`
	UnitPrice  pgtype.Numeric `json:"unit_price"`
	TotalPrice pgtype.Numeric `json:"total_price"`
}

func (q *Queries) CreateOrderItem(ctx context.Context, arg CreateOrderItemParams) (OrderItem, error) {
	row := q.db.QueryRow(ctx, createOrderItem,
		arg.OrderID,
		arg.ProductID,
		arg.Quantity,
		arg.UnitPrice,
		arg.TotalPrice,
	)
	var i OrderItem
	err := row.Scan(
		&i.ID,
		&i.OrderID,
		&i.ProductID,
		&i.Quantity,
		&i.UnitPrice,
		&i.TotalPrice,
	)
	return i, err
}

const getOrderItems = `-- name: GetOrderItems :many
SELECT 
    oi.id, oi.order_id, oi.product_id, oi.quantity, oi.unit_price, oi.total_price, 
    p.name as product_name 
FROM order_items oi
JOIN products p ON oi.product_id = p.id
WHERE oi.order_id = $1
`

type GetOrderItemsRow struct {
	ID          pgtype.UUID    `json:"id"`
	OrderID     pgtype.UUID    `json:"order_id"`
	ProductID   pgtype.UUID    `json:"product_id"`
	Quantity    int32          `json:"quantity"`
	UnitPrice   pgtype.Numeric `json:"unit_price"`
	TotalPrice  pgtype.Numeric `json:"total_price"`
	ProductName string         `json:"product_name"`
}

func (q *Queries) GetOrderItems(ctx context.Context, orderID pgtype.UUID) ([]GetOrderItemsRow, error) {
	rows, err := q.db.Query(ctx, getOrderItems, orderID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetOrderItemsRow
	for rows.Next() {
		var i GetOrderItemsRow
		if err := rows.Scan(
			&i.ID,
			&i.OrderID,
			&i.ProductID,
			&i.Quantity,
			&i.UnitPrice,
			&i.TotalPrice,
			&i.ProductName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listOrders = `-- name: ListOrders :many
SELECT 
    o.id, 
    o.total_amount, 
    o.status, 
    o.created_at,
    c.name as customer_name
FROM orders o
JOIN customers c ON o.customer_id = c.id
WHERE o.organization_id = $1
ORDER BY o.created_at DESC
`

type ListOrdersRow struct {
	ID           pgtype.UUID        `json:"id"`
	TotalAmount  pgtype.Numeric     `json:"total_amount"`
	Status       string             `json:"status"`
	CreatedAt    pgtype.Timestamptz `json:"created_at"`
	CustomerName string             `json:"customer_name"`
}

func (q *Queries) ListOrders(ctx context.Context, organizationID pgtype.UUID) ([]ListOrdersRow, error) {
	rows, err := q.db.Query(ctx, listOrders, organizationID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListOrdersRow
	for rows.Next() {
		var i ListOrdersRow
		if err := rows.Scan(
			&i.ID,
			&i.TotalAmount,
			&i.Status,
			&i.CreatedAt,
			&i.CustomerName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateProductStock = `-- name: UpdateProductStock :exec
UPDATE products
SET stock_quantity = stock_quantity - $2
WHERE id = $1 AND stock_quantity >= $2
`

type UpdateProductStockParams struct {
	ID            pgtype.UUID `json:"id"`
	StockQuantity int32       `json:"stock_quantity"`
}

func (q *Queries) UpdateProductStock(ctx context.Context, arg UpdateProductStockParams) error {
	_, err := q.db.Exec(ctx, updateProductStock, arg.ID, arg.StockQuantity)
	return err
}
